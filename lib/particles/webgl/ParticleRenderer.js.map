{"version":3,"sources":["../../../src/particles/webgl/ParticleRenderer.js"],"names":["core","ParticleRenderer","renderer","shader","indexBuffer","properties","tempMatrix","Matrix","CONTEXT_UID","onContextChange","gl","ParticleShader","attribute","attributes","aVertexPosition","size","uploadFunction","uploadVertices","offset","aPositionCoord","uploadPosition","aRotation","uploadRotation","aTextureCoord","uploadUvs","aColor","uploadAlpha","start","bindShader","render","container","children","maxSize","_maxSize","batchSize","_batchSize","totalChildren","length","buffers","_glBuffers","generateBuffers","setBlendMode","blendMode","m","worldTransform","copy","prepend","_activeRenderTarget","projectionMatrix","uniforms","toArray","uAlpha","worldAlpha","baseTexture","_texture","uSampler","bindTexture","i","j","amount","buffer","uploadDynamic","_bufferToUpdate","uploadStatic","bindVao","vao","draw","TRIANGLES","dynamicPropertyFlags","_properties","push","ParticleBuffer","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","scale","x","sy","y","trim","orig","anchor","width","height","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","spriteAlpha","alpha","destroy","deleteBuffer","indices","ObjectRenderer","WebGLRenderer","registerPlugin"],"mappings":"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","file":"ParticleRenderer.js","sourcesContent":["import * as core from '../../core';\nimport ParticleShader from './ParticleShader';\nimport ParticleBuffer from './ParticleBuffer';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class ParticleRenderer extends core.ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        /**\n         * The default shader that is used if a sprite doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        this.indexBuffer = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new core.Matrix();\n\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * When there is a WebGL context change\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // setup default shader\n        this.shader = new ParticleShader(gl);\n\n        this.properties = [\n            // verticesData\n            {\n                attribute: this.shader.attributes.aVertexPosition,\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attribute: this.shader.attributes.aPositionCoord,\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attribute: this.shader.attributes.aRotation,\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attribute: this.shader.attributes.aTextureCoord,\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // alphaData\n            {\n                attribute: this.shader.attributes.aColor,\n                size: 1,\n                uploadFunction: this.uploadAlpha,\n                offset: 0,\n            },\n        ];\n    }\n\n    /**\n     * Starts a new particle batch.\n     *\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n    }\n\n    /**\n     * Renders the particle container object.\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     */\n    render(container)\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n        if (!buffers)\n        {\n            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n        }\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.renderer.setBlendMode(container.blendMode);\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copy(this.tempMatrix);\n\n        m.prepend(renderer._activeRenderTarget.projectionMatrix);\n\n        this.shader.uniforms.projectionMatrix = m.toArray(true);\n        this.shader.uniforms.uAlpha = container.worldAlpha;\n\n        // make sure the texture is bound..\n        const baseTexture = children[0]._texture.baseTexture;\n\n        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            // we only upload the static content when we have to!\n            if (container._bufferToUpdate === j)\n            {\n                buffer.uploadStatic(children, i, amount);\n                container._bufferToUpdate = j + 1;\n            }\n\n            // bind the buffer\n            renderer.bindVao(buffer.vao);\n            buffer.vao.draw(gl.TRIANGLES, amount * 6);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer[]} The buffers\n     */\n    generateBuffers(container)\n    {\n        const gl = this.renderer.gl;\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Uploads the verticies.\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their vertices uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadVertices(children, startIndex, amount, array, stride, offset)\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their positions uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadPosition(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadRotation(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadUvs(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadAlpha(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteAlpha = children[startIndex + i].alpha;\n\n            array[offset] = spriteAlpha;\n            array[offset + stride] = spriteAlpha;\n            array[offset + (stride * 2)] = spriteAlpha;\n            array[offset + (stride * 3)] = spriteAlpha;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Destroys the ParticleRenderer.\n     *\n     */\n    destroy()\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.gl.deleteBuffer(this.indexBuffer);\n        }\n\n        super.destroy();\n\n        this.shader.destroy();\n\n        this.indices = null;\n        this.tempMatrix = null;\n    }\n\n}\n\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);\n"]}