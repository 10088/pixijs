{"version":3,"sources":["../../../../src/core/renderers/webgl/WebGLRenderer.js"],"names":["CONTEXT_UID","WebGLRenderer","screenWidth","screenHeight","options","legacy","glCore","VertexArrayObject","FORCE_NATIVE","type","RENDERER_TYPE","WEBGL","handleContextLost","bind","handleContextRestored","view","addEventListener","_contextOptions","alpha","transparent","antialias","premultipliedAlpha","stencil","preserveDrawingBuffer","_backgroundColorRgba","maskManager","MaskManager","stencilManager","StencilManager","emptyRenderer","ObjectRenderer","currentRenderer","initPlugins","context","gl","createContext","state","WebGLState","renderingToScreen","boundTextures","_activeShader","_activeVao","_activeRenderTarget","_initContext","filterManager","FilterManager","drawModes","_nextTextureLocation","setBlendMode","isContextLost","getExtension","restoreContext","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","Array","emptyTextures","textureManager","TextureManager","textureGC","TextureGarbageCollector","resetToDefault","rootRenderTarget","RenderTarget","width","height","resolution","clearColor","bindRenderTarget","emptyGLTexture","GLTexture","fromData","tempObj","_glTextures","i","empty","BaseTexture","bindTexture","emit","resize","screen","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","_lastObjectRendered","cacheParent","parent","_tempDisplayObjectParent","updateTransform","bindRenderTexture","start","undefined","clearBeforeRender","renderWebGL","flush","update","setObjectRenderer","objectRenderer","stop","SystemRenderer","prototype","call","activate","uniforms","projectionMatrix","toArray","blendMode","setTransform","matrix","clearRenderTexture","baseTexture","renderTarget","_glRenderTargets","updateTexture","unbindTexture","setFrame","frame","setMaskStack","stencilMaskStack","bindShader","shader","autoProject","texture","location","forceLocation","touched","count","length","glTexture","activeTexture","TEXTURE0","TEXTURE_2D","createVao","attribState","bindVao","vao","unbind","reset","event","preventDefault","removeAll","destroy","removeView","destroyPlugins","removeEventListener","uid","useProgram","loseContext","pluginTarget","mixin"],"mappings":"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","file":"WebGLRenderer.js","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport MaskManager from './managers/MaskManager';\nimport StencilManager from './managers/StencilManager';\nimport FilterManager from './managers/FilterManager';\nimport RenderTarget from './utils/RenderTarget';\nimport ObjectRenderer from './utils/ObjectRenderer';\nimport TextureManager from './TextureManager';\nimport BaseTexture from '../../textures/BaseTexture';\nimport TextureGarbageCollector from './TextureGarbageCollector';\nimport WebGLState from './WebGLState';\nimport mapWebGLDrawModesToPixi from './utils/mapWebGLDrawModesToPixi';\nimport validateContext from './utils/validateContext';\nimport { pluginTarget } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport { RENDERER_TYPE } from '../../const';\n\nlet CONTEXT_UID = 0;\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class WebGLRenderer extends SystemRenderer\n{\n    /**\n     *\n     * @param {number} [screenWidth=800] - the width of the screen\n     * @param {number} [screenHeight=600] - the height of the screen\n     * @param {object} [options] - The optional renderer parameters\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n     *  antialiasing is used\n     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n     *  FXAA is faster, but may not always look as great\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n     *  The resolution of the renderer retina would be 2.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear\n     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n     *  preserveDrawingBuffer to `true`.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when\n     *  rendering, stopping pixel interpolation.\n     * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility\n     * with older / less advanced devices. If you experiance unexplained flickering try setting this to true.\n     */\n    constructor(screenWidth, screenHeight, options = {})\n    {\n        super('WebGL', screenWidth, screenHeight, options);\n\n        this.legacy = !!options.legacy;\n\n        if (this.legacy)\n        {\n            glCore.VertexArrayObject.FORCE_NATIVE = true;\n        }\n\n        /**\n         * The type of this renderer as a standardised const\n         *\n         * @member {number}\n         * @see PIXI.RENDERER_TYPE\n         */\n        this.type = RENDERER_TYPE.WEBGL;\n\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n\n        this.view.addEventListener('webglcontextlost', this.handleContextLost, false);\n        this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n\n        /**\n         * The options passed in to create a new webgl context.\n         *\n         * @member {object}\n         * @private\n         */\n        this._contextOptions = {\n            alpha: this.transparent,\n            antialias: options.antialias,\n            premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n            stencil: true,\n            preserveDrawingBuffer: options.preserveDrawingBuffer,\n        };\n\n        this._backgroundColorRgba[3] = this.transparent ? 0 : 1;\n\n        /**\n         * Manages the masks using the stencil buffer.\n         *\n         * @member {PIXI.MaskManager}\n         */\n        this.maskManager = new MaskManager(this);\n\n        /**\n         * Manages the stencil buffer.\n         *\n         * @member {PIXI.StencilManager}\n         */\n        this.stencilManager = new StencilManager(this);\n\n        /**\n         * An empty renderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.emptyRenderer = new ObjectRenderer(this);\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.currentRenderer = this.emptyRenderer;\n\n        this.initPlugins();\n\n        /**\n         * The current WebGL rendering context, it is created here\n         *\n         * @member {WebGLRenderingContext}\n         */\n        // initialize the context so it is ready for the managers.\n        if (options.context)\n        {\n            // checks to see if a context is valid..\n            validateContext(options.context);\n        }\n\n        this.gl = options.context || glCore.createContext(this.view, this._contextOptions);\n\n        this.CONTEXT_UID = CONTEXT_UID++;\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.WebGLState}\n         */\n        this.state = new WebGLState(this.gl);\n\n        this.renderingToScreen = true;\n\n        /**\n         * Holds the current state of textures bound to the GPU.\n         * @type {Array}\n         */\n        this.boundTextures = null;\n\n        /**\n         * Holds the current shader\n         *\n         * @member {PIXI.Shader}\n         */\n        this._activeShader = null;\n\n        this._activeVao = null;\n\n        /**\n         * Holds the current render target\n         *\n         * @member {PIXI.RenderTarget}\n         */\n        this._activeRenderTarget = null;\n\n        this._initContext();\n\n        /**\n         * Manages the filters.\n         *\n         * @member {PIXI.FilterManager}\n         */\n        this.filterManager = new FilterManager(this);\n        // map some webGL blend and drawmodes..\n        this.drawModes = mapWebGLDrawModesToPixi(this.gl);\n\n        this._nextTextureLocation = 0;\n\n        this.setBlendMode(0);\n    }\n\n    /**\n     * Creates the WebGL context\n     *\n     * @private\n     */\n    _initContext()\n    {\n        const gl = this.gl;\n\n        // restore a context if it was previously lost\n        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context'))\n        {\n            gl.getExtension('WEBGL_lose_context').restoreContext();\n        }\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this.boundTextures = new Array(maxTextures);\n        this.emptyTextures = new Array(maxTextures);\n\n        // create a texture manager...\n        this.textureManager = new TextureManager(this);\n        this.textureGC = new TextureGarbageCollector(this);\n\n        this.state.resetToDefault();\n\n        this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);\n        this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n\n        this.bindRenderTarget(this.rootRenderTarget);\n\n        // now lets fill up the textures with empty ones!\n        const emptyGLTexture = new glCore.GLTexture.fromData(gl, null, 1, 1);\n\n        const tempObj = { _glTextures: {} };\n\n        tempObj._glTextures[this.CONTEXT_UID] = {};\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            const empty = new BaseTexture();\n\n            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n\n            this.boundTextures[i] = tempObj;\n            this.emptyTextures[i] = empty;\n            this.bindTexture(null, i);\n        }\n\n        this.emit('context', gl);\n\n        // setup the width/height properties and gl viewport\n        this.resize(this.screen.width, this.screen.height);\n    }\n\n    /**\n     * Renders the object to its webGL view\n     *\n     * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n     * @param {boolean} [clear] - Should the canvas be cleared before the new render\n     * @param {PIXI.Transform} [transform] - A transform to apply to the render texture before rendering.\n     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        // no point rendering if our context has been blown up!\n        if (!this.gl || this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this._nextTextureLocation = 0;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n\n            displayObject.parent = this._tempDisplayObjectParent;\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n           // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        this.bindRenderTexture(renderTexture, transform);\n\n        this.currentRenderer.start();\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            this._activeRenderTarget.clear();\n        }\n\n        displayObject.renderWebGL(this);\n\n        // apply transform..\n        this.currentRenderer.flush();\n\n        // this.setObjectRenderer(this.emptyRenderer);\n\n        this.textureGC.update();\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Changes the current renderer to the one given in parameter\n     *\n     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n     */\n    setObjectRenderer(objectRenderer)\n    {\n        if (this.currentRenderer === objectRenderer)\n        {\n            return;\n        }\n\n        this.currentRenderer.stop();\n        this.currentRenderer = objectRenderer;\n        this.currentRenderer.start();\n    }\n\n    /**\n     * This should be called if you wish to do some custom rendering\n     * It will basically render anything that may be batched up such as sprites\n     *\n     */\n    flush()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n      //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n\n        SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);\n\n        this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n        if (this._activeRenderTarget === this.rootRenderTarget)\n        {\n            this.rootRenderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} blendMode - the desired blend mode\n     */\n    setBlendMode(blendMode)\n    {\n        this.state.setBlendMode(blendMode);\n    }\n\n    /**\n     * Erases the active render target and fills the drawing area with a colour\n     *\n     * @param {number} [clearColor] - The colour\n     */\n    clear(clearColor)\n    {\n        this._activeRenderTarget.clear(clearColor);\n    }\n\n    /**\n     * Sets the transform of the active render target to the given matrix\n     *\n     * @param {PIXI.Matrix} matrix - The transformation matrix\n     */\n    setTransform(matrix)\n    {\n        this._activeRenderTarget.transform = matrix;\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n     * @param {number} [clearColor] - The colour\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    clearRenderTexture(renderTexture, clearColor)\n    {\n        const baseTexture = renderTexture.baseTexture;\n        const renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n        if (renderTarget)\n        {\n            renderTarget.clear(clearColor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds a render texture for rendering\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n     * @param {PIXI.Transform} transform - The transform to be applied to the render texture\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTexture(renderTexture, transform)\n    {\n        let renderTarget;\n\n        if (renderTexture)\n        {\n            const baseTexture = renderTexture.baseTexture;\n\n            if (!baseTexture._glRenderTargets[this.CONTEXT_UID])\n            {\n                // bind the current texture\n                this.textureManager.updateTexture(baseTexture, 0);\n            }\n\n            this.unbindTexture(baseTexture);\n\n            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n            renderTarget.setFrame(renderTexture.frame);\n        }\n        else\n        {\n            renderTarget = this.rootRenderTarget;\n        }\n\n        renderTarget.transform = transform;\n        this.bindRenderTarget(renderTarget);\n\n        return this;\n    }\n\n    /**\n     * Changes the current render target to the one given in parameter\n     *\n     * @param {PIXI.RenderTarget} renderTarget - the new render target\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTarget(renderTarget)\n    {\n        if (renderTarget !== this._activeRenderTarget)\n        {\n            this._activeRenderTarget = renderTarget;\n            renderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n            }\n\n            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter\n     *\n     * @param {PIXI.Shader} shader - the new shader\n     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindShader(shader, autoProject)\n    {\n        // TODO cache\n        if (this._activeShader !== shader)\n        {\n            this._activeShader = shader;\n            shader.bind();\n\n            // `autoProject` normally would be a default parameter set to true\n            // but because of how Babel transpiles default parameters\n            // it hinders the performance of this method.\n            if (autoProject !== false)\n            {\n                // automatically set the projection matrix\n                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds the texture. This will return the location of the bound texture.\n     * It may not be the same as the one you pass in. This is due to optimisation that prevents\n     * needless binding of textures. For example if the texture is already bound it will return the\n     * current location of the texture instead of the one provided. To bypass this use force location\n     *\n     * @param {PIXI.Texture} texture - the new texture\n     * @param {number} location - the suggested texture location\n     * @param {boolean} forceLocation - force the location\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindTexture(texture, location, forceLocation)\n    {\n        texture = texture || this.emptyTextures[location];\n        texture = texture.baseTexture || texture;\n        texture.touched = this.textureGC.count;\n\n        if (!forceLocation)\n        {\n            // TODO - maybe look into adding boundIds.. save us the loop?\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === texture)\n                {\n                    return i;\n                }\n            }\n\n            if (location === undefined)\n            {\n                this._nextTextureLocation++;\n                this._nextTextureLocation %= this.boundTextures.length;\n                location = this.boundTextures.length - this._nextTextureLocation - 1;\n            }\n        }\n        else\n        {\n            location = location || 0;\n        }\n\n        const gl = this.gl;\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            // this will also bind the texture..\n            this.textureManager.updateTexture(texture, location);\n        }\n        else\n        {\n            // bind the current texture\n            this.boundTextures[location] = texture;\n            gl.activeTexture(gl.TEXTURE0 + location);\n            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        }\n\n        return location;\n    }\n\n     /**\n     * unbinds the texture ...\n     *\n     * @param {PIXI.Texture} texture - the texture to unbind\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    unbindTexture(texture)\n    {\n        const gl = this.gl;\n\n        texture = texture.baseTexture || texture;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            if (this.boundTextures[i] === texture)\n            {\n                this.boundTextures[i] = this.emptyTextures[i];\n\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Creates a new VAO from this renderer's context and state.\n     *\n     * @return {VertexArrayObject} The new VAO.\n     */\n    createVao()\n    {\n        return new glCore.VertexArrayObject(this.gl, this.state.attribState);\n    }\n\n    /**\n     * Changes the current Vao to the one given in parameter\n     *\n     * @param {PIXI.VertexArrayObject} vao - the new Vao\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindVao(vao)\n    {\n        if (this._activeVao === vao)\n        {\n            return this;\n        }\n\n        if (vao)\n        {\n            vao.bind();\n        }\n        else if (this._activeVao)\n        {\n            // TODO this should always be true i think?\n            this._activeVao.unbind();\n        }\n\n        this._activeVao = vao;\n\n        return this;\n    }\n\n    /**\n     * Resets the WebGL state so you can render things however you fancy!\n     *\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    reset()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n\n        this._activeShader = null;\n        this._activeRenderTarget = this.rootRenderTarget;\n\n        // bind the main frame buffer (the screen);\n        this.rootRenderTarget.activate();\n\n        this.state.resetToDefault();\n\n        return this;\n    }\n\n    /**\n     * Handles a lost webgl context\n     *\n     * @private\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    handleContextLost(event)\n    {\n        event.preventDefault();\n    }\n\n    /**\n     * Handles a restored webgl context\n     *\n     * @private\n     */\n    handleContextRestored()\n    {\n        this._initContext();\n        this.textureManager.removeAll();\n    }\n\n    /**\n     * Removes everything from the renderer (event listeners, spritebatch, etc...)\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     *  See: https://github.com/pixijs/pixi.js/issues/2233\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // remove listeners\n        this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.textureManager.destroy();\n\n        // call base destroy\n        super.destroy(removeView);\n\n        this.uid = 0;\n\n        // destroy the managers\n        this.maskManager.destroy();\n        this.stencilManager.destroy();\n        this.filterManager.destroy();\n\n        this.maskManager = null;\n        this.filterManager = null;\n        this.textureManager = null;\n        this.currentRenderer = null;\n\n        this.handleContextLost = null;\n        this.handleContextRestored = null;\n\n        this._contextOptions = null;\n        this.gl.useProgram(null);\n\n        if (this.gl.getExtension('WEBGL_lose_context'))\n        {\n            this.gl.getExtension('WEBGL_lose_context').loseContext();\n        }\n\n        this.gl = null;\n\n        // this = null;\n    }\n}\n\npluginTarget.mixin(WebGLRenderer);\n"]}