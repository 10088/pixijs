{"version":3,"sources":["../../../src/core/display/TransformBase.js"],"names":["TransformBase","worldTransform","Matrix","localTransform","_worldID","_parentID","updateLocalTransform","updateTransform","parentTransform","pt","wt","lt","a","b","c","d","tx","ty","prototype","updateWorldTransform","IDENTITY"],"mappings":";;;;AAAA;;;;AAEA;;;;;;IAMqBA,a;AAEjB;;;AAGA,2BACA;AAAA;;AACI;;;;;AAKA,SAAKC,cAAL,GAAsB,IAAIC,YAAJ,EAAtB;;AAEA;;;;;AAKA,SAAKC,cAAL,GAAsB,IAAID,YAAJ,EAAtB;;AAEA,SAAKE,QAAL,GAAgB,CAAhB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACH;;AAED;;;;;0BAGAC,oB,mCACA,CAEC;AADG;;;AAGJ;;;;;;;0BAKAC,e,4BAAgBC,e,EAChB;AACI,QAAMC,KAAKD,gBAAgBP,cAA3B;AACA,QAAMS,KAAK,KAAKT,cAAhB;AACA,QAAMU,KAAK,KAAKR,cAAhB;;AAEA;AACAO,OAAGE,CAAH,GAAQD,GAAGC,CAAH,GAAOH,GAAGG,CAAX,GAAiBD,GAAGE,CAAH,GAAOJ,GAAGK,CAAlC;AACAJ,OAAGG,CAAH,GAAQF,GAAGC,CAAH,GAAOH,GAAGI,CAAX,GAAiBF,GAAGE,CAAH,GAAOJ,GAAGM,CAAlC;AACAL,OAAGI,CAAH,GAAQH,GAAGG,CAAH,GAAOL,GAAGG,CAAX,GAAiBD,GAAGI,CAAH,GAAON,GAAGK,CAAlC;AACAJ,OAAGK,CAAH,GAAQJ,GAAGG,CAAH,GAAOL,GAAGI,CAAX,GAAiBF,GAAGI,CAAH,GAAON,GAAGM,CAAlC;AACAL,OAAGM,EAAH,GAASL,GAAGK,EAAH,GAAQP,GAAGG,CAAZ,GAAkBD,GAAGM,EAAH,GAAQR,GAAGK,CAA7B,GAAkCL,GAAGO,EAA7C;AACAN,OAAGO,EAAH,GAASN,GAAGK,EAAH,GAAQP,GAAGI,CAAZ,GAAkBF,GAAGM,EAAH,GAAQR,GAAGM,CAA7B,GAAkCN,GAAGQ,EAA7C;;AAEA,SAAKb,QAAL;AACH,G;;;;;AAIL;;;;;;;kBAzDqBJ,a;AA8DrBA,cAAckB,SAAd,CAAwBC,oBAAxB,GAA+CnB,cAAckB,SAAd,CAAwBX,eAAvE;;AAEAP,cAAcoB,QAAd,GAAyB,IAAIpB,aAAJ,EAAzB","file":"TransformBase.js","sourcesContent":["import { Matrix } from '../math';\n\n/**\n * Generic class to deal with traditional 2D matrix transforms\n *\n * @class\n * @memberof PIXI\n */\nexport default class TransformBase\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.worldTransform = new Matrix();\n\n        /**\n         * The local matrix transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.localTransform = new Matrix();\n\n        this._worldID = 0;\n        this._parentID = 0;\n    }\n\n    /**\n     * TransformBase does not have decomposition, so this function wont do anything\n     */\n    updateLocalTransform()\n    {\n        // empty\n    }\n\n    /**\n     * Updates the values of the object and applies the parent's transform.\n     *\n     * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object\n     */\n    updateTransform(parentTransform)\n    {\n        const pt = parentTransform.worldTransform;\n        const wt = this.worldTransform;\n        const lt = this.localTransform;\n\n        // concat the parent matrix with the objects transform.\n        wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n        wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n        wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n        wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n        wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n        wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n\n        this._worldID ++;\n    }\n\n}\n\n/**\n * Updates the values of the object and applies the parent's transform.\n * @param  parentTransform {PIXI.Transform} The transform of the parent of this object\n *\n */\nTransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;\n\nTransformBase.IDENTITY = new TransformBase();\n"]}