{"version":3,"sources":["../../../src/core/text/Text.js"],"names":["defaultDestroyOptions","texture","children","baseTexture","Text","text","style","canvas","document","createElement","width","height","Texture","fromCanvas","orig","Rectangle","trim","context","getContext","resolution","settings","RESOLUTION","_text","_style","_styleListener","_font","localStyleID","updateText","respectDirty","styleID","dirty","getFontStyle","font","outputText","wordWrap","lines","split","lineWidths","Array","length","maxLineWidth","fontProperties","calculateFontProperties","i","lineWidth","measureText","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","ceil","padding","lineHeight","fontSize","scale","clearRect","strokeStyle","stroke","textBaseline","lineJoin","miterLimit","linePositionX","linePositionY","shadowBlur","dropShadowBlur","globalAlpha","dropShadowAlpha","shadowColor","dropShadowColor","fillStyle","xShadowOffset","cos","dropShadowAngle","yShadowOffset","sin","ascent","align","fill","drawLetterSpacing","_generateFillStyle","updateTexture","x","y","isStroke","strokeText","fillText","characters","String","prototype","call","currentPosition","index","current","trimmed","putImageData","data","_texture","hasLoaded","realWidth","realHeight","_frame","_onTextureUpdate","emit","renderWebGL","renderer","_renderCanvas","result","wordWrapWidth","spaceLeft","words","j","wordWidth","breakWords","c","characterWidth","wordWidthWithSpace","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","isArray","navigator","isCocoonJS","gradient","totalIterations","currentIteration","stop","slice","fillGradientStops","lengthPlus1","push","unshift","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","createLinearGradient","addColorStop","destroy","options","Object","assign","TextStyle","fontSizeString","fontFamilies","fontFamily","test","fontStyle","fontVariant","fontWeight","join","fontPropertiesCache","properties","fontPropertiesCanvas","fontPropertiesContext","baseline","fillRect","imagedata","getImageData","pixels","line","idx","descent","abs","value","s","_width","_height","undefined","Sprite"],"mappings":"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","file":"Text.js","sourcesContent":["/* eslint max-depth: [2, 8] */\nimport Sprite from '../sprites/Sprite';\nimport Texture from '../textures/Texture';\nimport { Rectangle } from '../math';\nimport { sign } from '../utils';\nimport { TEXT_GRADIENT } from '../const';\nimport settings from '../settings';\nimport TextStyle from './TextStyle';\nimport trimCanvas from '../utils/trimCanvas';\n\nconst defaultDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * let text = new PIXI.Text('This is a pixi text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nexport default class Text extends Sprite\n{\n    /**\n     * @param {string} text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n     */\n    constructor(text, style, canvas)\n    {\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.fromCanvas(canvas);\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        /**\n         * The canvas element that everything is drawn to\n         *\n         * @member {HTMLCanvasElement}\n         */\n        this.canvas = canvas;\n\n        /**\n         * The canvas 2d context that everything is drawn with\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.canvas.getContext('2d');\n\n        /**\n         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = settings.RESOLUTION;\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = null;\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._style = null;\n        /**\n         * Private listener to track style changes.\n         *\n         * @member {Function}\n         * @private\n         */\n        this._styleListener = null;\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {string}\n         * @private\n         */\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text and updates it when needed.\n     *\n     * @private\n     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = Text.getFontStyle(style);\n\n        this.context.font = this._font;\n\n        // word wrap\n        // preserve original text\n        const outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;\n\n        // split text into lines\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n        // calculate text width\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        const fontProperties = Text.calculateFontProperties(this._font);\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = this.context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        let width = maxLineWidth + style.strokeThickness;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadowDistance;\n        }\n\n        this.canvas.width = Math.ceil((width + (style.padding * 2)) * this.resolution);\n\n        // calculate text height\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)\n            + ((lines.length - 1) * lineHeight);\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadowDistance;\n        }\n\n        this.canvas.height = Math.ceil((height + (style.padding * 2)) * this.resolution);\n\n        this.context.scale(this.resolution, this.resolution);\n\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        this.context.font = this._font;\n        this.context.strokeStyle = style.stroke;\n        this.context.lineWidth = style.strokeThickness;\n        this.context.textBaseline = style.textBaseline;\n        this.context.lineJoin = style.lineJoin;\n        this.context.miterLimit = style.miterLimit;\n\n        let linePositionX;\n        let linePositionY;\n\n        if (style.dropShadow)\n        {\n            this.context.shadowBlur = style.dropShadowBlur;\n            this.context.globalAlpha = style.dropShadowAlpha;\n\n            if (style.dropShadowBlur > 0)\n            {\n                this.context.shadowColor = style.dropShadowColor;\n            }\n            else\n            {\n                this.context.fillStyle = style.dropShadowColor;\n            }\n\n            const xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n            const yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding\n                    );\n\n                    if (style.stroke && style.strokeThickness)\n                    {\n                        this.context.strokeStyle = style.dropShadowColor;\n                        this.drawLetterSpacing(\n                            lines[i],\n                            linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding,\n                            true\n                        );\n                        this.context.strokeStyle = style.stroke;\n                    }\n                }\n            }\n        }\n\n        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n        this.context.shadowBlur = 0;\n        this.context.globalAlpha = 1;\n\n        // set canvas text styles\n        this.context.fillStyle = this._generateFillStyle(style, lines);\n\n        // draw lines line by line\n        for (let i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.stroke && style.strokeThickness)\n            {\n                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, true);\n            }\n\n            if (style.fill)\n            {\n                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding);\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param {string} text - The text to draw\n     * @param {number} x - Horizontal position to draw the text\n     * @param {number} y - Vertical position to draw the text\n     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     * @private\n     */\n    drawLetterSpacing(text, x, y, isStroke = false)\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        if (letterSpacing === 0)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        const characters = String.prototype.split.call(text, '');\n        let currentPosition = x;\n        let index = 0;\n        let current = '';\n\n        while (index < text.length)\n        {\n            current = characters[index++];\n            if (isStroke)\n            {\n                this.context.strokeText(current, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(current, currentPosition, y);\n            }\n            currentPosition += this.context.measureText(current).width + letterSpacing;\n        }\n    }\n\n    /**\n     * Updates texture size based on canvas size\n     *\n     * @private\n     */\n    updateTexture()\n    {\n        if (this._style.trim)\n        {\n            const trimmed = trimCanvas(this.canvas);\n\n            this.canvas.width = trimmed.width;\n            this.canvas.height = trimmed.height;\n            this.context.putImageData(trimmed.data, 0, 0);\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n\n        texture.baseTexture.hasLoaded = true;\n        texture.baseTexture.resolution = this.resolution;\n\n        texture.baseTexture.realWidth = this.canvas.width;\n        texture.baseTexture.realHeight = this.canvas.height;\n        texture.baseTexture.width = this.canvas.width / this.resolution;\n        texture.baseTexture.height = this.canvas.height / this.resolution;\n        texture.trim.width = texture._frame.width = this.canvas.width / this.resolution;\n        texture.trim.height = texture._frame.height = this.canvas.height / this.resolution;\n\n        texture.trim.x = -style.padding;\n        texture.trim.y = -style.padding;\n\n        texture.orig.width = texture._frame.width - (style.padding * 2);\n        texture.orig.height = texture._frame.height - (style.padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        texture.baseTexture.emit('update', texture.baseTexture);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super.renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     *\n     * @private\n     * @param {string} text - String to apply word wrapping to\n     * @return {string} New string with new lines applied where required\n     */\n    wordWrap(text)\n    {\n        // Greedy wrapping algorithm that will wrap words as the line grows longer\n        // than its horizontal bounds.\n        let result = '';\n        const style = this._style;\n        const lines = text.split('\\n');\n        const wordWrapWidth = style.wordWrapWidth;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            let spaceLeft = wordWrapWidth;\n            const words = lines[i].split(' ');\n\n            for (let j = 0; j < words.length; j++)\n            {\n                const wordWidth = this.context.measureText(words[j]).width;\n\n                if (style.breakWords && wordWidth > wordWrapWidth)\n                {\n                    // Word should be split in the middle\n                    const characters = words[j].split('');\n\n                    for (let c = 0; c < characters.length; c++)\n                    {\n                        const characterWidth = this.context.measureText(characters[c]).width;\n\n                        if (characterWidth > spaceLeft)\n                        {\n                            result += `\\n${characters[c]}`;\n                            spaceLeft = wordWrapWidth - characterWidth;\n                        }\n                        else\n                        {\n                            if (c === 0)\n                            {\n                                result += ' ';\n                            }\n\n                            result += characters[c];\n                            spaceLeft -= characterWidth;\n                        }\n                    }\n                }\n                else\n                {\n                    const wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n\n                    if (j === 0 || wordWidthWithSpace > spaceLeft)\n                    {\n                        // Skip printing the newline if it's the first word of the line that is\n                        // greater than the word wrap width.\n                        if (j > 0)\n                        {\n                            result += '\\n';\n                        }\n                        result += words[j];\n                        spaceLeft = wordWrapWidth - wordWidth;\n                    }\n                    else\n                    {\n                        spaceLeft -= wordWidthWithSpace;\n                        result += ` ${words[j]}`;\n                    }\n                }\n            }\n\n            if (i < lines.length - 1)\n            {\n                result += '\\n';\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     *\n     * @param {Rectangle} rect - The output rectangle.\n     * @return {Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n     */\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Method to be called upon a TextStyle change.\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     *\n     * @private\n     * @param {object} style - The style.\n     * @param {string[]} lines - The lines of text.\n     * @return {string|number|CanvasGradient} The fill style\n     */\n    _generateFillStyle(style, lines)\n    {\n        if (!Array.isArray(style.fill))\n        {\n            return style.fill;\n        }\n\n        // cocoon on canvas+ cannot generate textures, so use the first colour instead\n        if (navigator.isCocoonJS)\n        {\n            return style.fill[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient;\n        let totalIterations;\n        let currentIteration;\n        let stop;\n\n        const width = this.canvas.width / this.resolution;\n        const height = this.canvas.height / this.resolution;\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = style.fill.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(style.fill[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(style.fill[style.fill.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n            totalIterations = (fill.length + 1) * lines.length;\n            currentIteration = 0;\n            for (let i = 0; i < lines.length; i++)\n            {\n                currentIteration += 1;\n                for (let j = 0; j < fill.length; j++)\n                {\n                    if (fillGradientStops[j])\n                    {\n                        stop = (fillGradientStops[j] / lines.length) + (i / lines.length);\n                    }\n                    else\n                    {\n                        stop = currentIteration / totalIterations;\n                    }\n                    gradient.addColorStop(stop, fill[j]);\n                    currentIteration++;\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            totalIterations = fill.length + 1;\n            currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                if (fillGradientStops[i])\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * Generates a font style string to use for Text.calculateFontProperties(). Takes the same parameter\n     * as Text.style.\n     *\n     * @static\n     * @param {object|TextStyle} style - String representing the style of the font\n     * @return {string} Font style string, for passing to Text.calculateFontProperties()\n     */\n    static getFontStyle(style)\n    {\n        style = style || {};\n\n        if (!(style instanceof TextStyle))\n        {\n            style = new TextStyle(style);\n        }\n\n        // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n        const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n        // Clean-up fontFamily property by quoting each font name\n        // this will support font names with spaces\n        let fontFamilies = style.fontFamily;\n\n        if (!Array.isArray(style.fontFamily))\n        {\n            fontFamilies = style.fontFamily.split(',');\n        }\n\n        for (let i = fontFamilies.length - 1; i >= 0; i--)\n        {\n            // Trim any extra white-space\n            let fontFamily = fontFamilies[i].trim();\n\n            // Check if font already contains strings\n            if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily))\n            {\n                fontFamily = `\"${fontFamily}\"`;\n            }\n            fontFamilies[i] = fontFamily;\n        }\n\n        return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(',')}`;\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given fontStyle\n     *\n     * @static\n     * @param {string} fontStyle - String representing the style of the font\n     * @return {Object} Font properties object\n     */\n    static calculateFontProperties(fontStyle)\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (Text.fontPropertiesCache[fontStyle])\n        {\n            return Text.fontPropertiesCache[fontStyle];\n        }\n\n        const properties = {};\n\n        const canvas = Text.fontPropertiesCanvas;\n        const context = Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        const width = Math.ceil(context.measureText('|MÉq').width);\n        let baseline = Math.ceil(context.measureText('M').width);\n        const height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        Text.fontPropertiesCache[fontStyle] = properties;\n\n        return properties;\n    }\n}\n\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\n"]}