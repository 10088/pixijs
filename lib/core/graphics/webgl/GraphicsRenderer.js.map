{"version":3,"sources":["../../../../src/core/graphics/webgl/GraphicsRenderer.js"],"names":["GraphicsRenderer","renderer","graphicsDataPool","primitiveShader","gl","CONTEXT_UID","onContextChange","PrimitiveShader","destroy","ObjectRenderer","prototype","call","i","length","render","graphics","webGLData","webGL","_webGL","dirty","updateGraphics","shader","bindShader","state","setBlendMode","blendMode","n","data","shaderTemp","uniforms","translationMatrix","transform","worldTransform","toArray","tint","alpha","worldAlpha","bindVao","vao","nativeLines","drawArrays","LINES","points","draw","TRIANGLE_STRIP","indices","lastIndex","clearDirty","push","graphicsData","getWebGLData","type","SHAPES","POLY","RECT","CIRC","ELIP","RREC","upload","pop","WebGLGraphicsData","attribsState","reset","WebGLRenderer","registerPlugin"],"mappings":"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","file":"GraphicsRenderer.js","sourcesContent":["import { hex2rgb } from '../../utils';\nimport { SHAPES } from '../../const';\nimport ObjectRenderer from '../../renderers/webgl/utils/ObjectRenderer';\nimport WebGLRenderer from '../../renderers/webgl/WebGLRenderer';\nimport WebGLGraphicsData from './WebGLGraphicsData';\nimport PrimitiveShader from './shaders/PrimitiveShader';\n\nimport buildPoly from './utils/buildPoly';\nimport buildRectangle from './utils/buildRectangle';\nimport buildRoundedRectangle from './utils/buildRoundedRectangle';\nimport buildCircle from './utils/buildCircle';\n\n/**\n * Renders the graphics object.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class GraphicsRenderer extends ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.graphicsDataPool = [];\n\n        this.primitiveShader = null;\n\n        this.gl = renderer.gl;\n\n        // easy access!\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * Called when there is a WebGL context change\n     *\n     * @private\n     *\n     */\n    onContextChange()\n    {\n        this.gl = this.renderer.gl;\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n        this.primitiveShader = new PrimitiveShader(this.gl);\n    }\n\n    /**\n     * Destroys this renderer.\n     *\n     */\n    destroy()\n    {\n        ObjectRenderer.prototype.destroy.call(this);\n\n        for (let i = 0; i < this.graphicsDataPool.length; ++i)\n        {\n            this.graphicsDataPool[i].destroy();\n        }\n\n        this.graphicsDataPool = null;\n    }\n\n    /**\n     * Renders a graphics object.\n     *\n     * @param {PIXI.Graphics} graphics - The graphics object to render.\n     */\n    render(graphics)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n\n        let webGLData;\n        let webGL = graphics._webGL[this.CONTEXT_UID];\n\n        if (!webGL || graphics.dirty !== webGL.dirty)\n        {\n            this.updateGraphics(graphics);\n\n            webGL = graphics._webGL[this.CONTEXT_UID];\n        }\n\n        // This  could be speeded up for sure!\n        const shader = this.primitiveShader;\n\n        renderer.bindShader(shader);\n        renderer.state.setBlendMode(graphics.blendMode);\n\n        for (let i = 0, n = webGL.data.length; i < n; i++)\n        {\n            webGLData = webGL.data[i];\n            const shaderTemp = webGLData.shader;\n\n            renderer.bindShader(shaderTemp);\n            shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);\n            shaderTemp.uniforms.tint = hex2rgb(graphics.tint);\n            shaderTemp.uniforms.alpha = graphics.worldAlpha;\n\n            renderer.bindVao(webGLData.vao);\n\n            if (graphics.nativeLines)\n            {\n                gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);\n            }\n            else\n            {\n                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);\n            }\n        }\n    }\n\n    /**\n     * Updates the graphics object\n     *\n     * @private\n     * @param {PIXI.Graphics} graphics - The graphics object to update\n     */\n    updateGraphics(graphics)\n    {\n        const gl = this.renderer.gl;\n\n         // get the contexts graphics object\n        let webGL = graphics._webGL[this.CONTEXT_UID];\n\n        // if the graphics object does not exist in the webGL context time to create it!\n        if (!webGL)\n        {\n            webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl, clearDirty: -1, dirty: -1 };\n        }\n\n        // flag the graphics as not dirty as we are about to update it...\n        webGL.dirty = graphics.dirty;\n\n        // if the user cleared the graphics object we will need to clear every object\n        if (graphics.clearDirty !== webGL.clearDirty)\n        {\n            webGL.clearDirty = graphics.clearDirty;\n\n            // loop through and return all the webGLDatas to the object pool so than can be reused later on\n            for (let i = 0; i < webGL.data.length; i++)\n            {\n                this.graphicsDataPool.push(webGL.data[i]);\n            }\n\n            // clear the array and reset the index..\n            webGL.data.length = 0;\n            webGL.lastIndex = 0;\n        }\n\n        let webGLData;\n\n        // loop through the graphics datas and construct each one..\n        // if the object is a complex fill then the new stencil buffer technique will be used\n        // other wise graphics objects will be pushed into a batch..\n        for (let i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n        {\n            const data = graphics.graphicsData[i];\n\n            // TODO - this can be simplified\n            webGLData = this.getWebGLData(webGL, 0);\n\n            if (data.type === SHAPES.POLY)\n            {\n                buildPoly(data, webGLData);\n            }\n            if (data.type === SHAPES.RECT)\n            {\n                buildRectangle(data, webGLData);\n            }\n            else if (data.type === SHAPES.CIRC || data.type === SHAPES.ELIP)\n            {\n                buildCircle(data, webGLData);\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                buildRoundedRectangle(data, webGLData);\n            }\n\n            webGL.lastIndex++;\n        }\n\n        this.renderer.bindVao(null);\n\n        // upload all the dirty data...\n        for (let i = 0; i < webGL.data.length; i++)\n        {\n            webGLData = webGL.data[i];\n\n            if (webGLData.dirty)\n            {\n                webGLData.upload();\n            }\n        }\n    }\n\n    /**\n     *\n     * @private\n     * @param {WebGLRenderingContext} gl - the current WebGL drawing context\n     * @param {number} type - TODO @Alvin\n     * @return {*} TODO\n     */\n    getWebGLData(gl, type)\n    {\n        let webGLData = gl.data[gl.data.length - 1];\n\n        if (!webGLData || webGLData.points.length > 320000)\n        {\n            webGLData = this.graphicsDataPool.pop()\n                || new WebGLGraphicsData(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);\n\n            webGLData.reset(type);\n            gl.data.push(webGLData);\n        }\n\n        webGLData.dirty = true;\n\n        return webGLData;\n    }\n}\n\nWebGLRenderer.registerPlugin('graphics', GraphicsRenderer);\n"]}